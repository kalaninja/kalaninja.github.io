<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | kalan&#39;s blog</title>
    <link>/post/</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2020 Alexander Kalankhodzhaev</copyright><lastBuildDate>Tue, 02 May 2017 13:15:00 +0300</lastBuildDate>
    <image>
      <url>/images/icon_hu45eb22dba3a74074a63777c2344b71bd_547989_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>/post/</link>
    </image>
    
    <item>
      <title>Finding winning strategies</title>
      <link>/post/finding-winning-strategies/</link>
      <pubDate>Tue, 02 May 2017 13:15:00 +0300</pubDate>
      <guid>/post/finding-winning-strategies/</guid>
      <description>&lt;p&gt;This time I want to show how to &lt;em&gt;solve a game&lt;/em&gt; using a perfect play which means being able to predict the outcome of the game from any position. The perfect play is the strategy that leads to the best possible outcome for that player regardless of the response by the opponent. For the illustration I have selected two children’s games with stones. The rules are very simple. There is a pile of 99 stones. Two player take &lt;strong&gt;n&lt;/strong&gt; stones out of the pile in turn. The one who takes the last stone is the winner. In each game &lt;strong&gt;n&lt;/strong&gt; is different:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;it is in the closed interval between 1 and 3&lt;/li&gt;
&lt;li&gt;power of 2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s find out how to always win these kind of games.&lt;/p&gt;
&lt;h2 id=&#34;problem-identification&#34;&gt;Problem identification&lt;/h2&gt;
&lt;p&gt;As both games are very similar I will talk about them as a single one. This is a game of two players with only two possible outcomes; either one or the other of the players wins, no draw is possible. So, this is a strictly competitive finite two-person game. As players move in turns and each player at all times is aware of all the events that have previously occurred, this is a game of perfect information. According to Zermelo’s theorem&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;the-algorithm&#34;&gt;The algorithm&lt;/h2&gt;
&lt;p&gt;Now that we know the type of problem we are dealing with this leads us to the main question of how to analyze the game. The answer is to model the game, which is to build a tree of all possible decisions made by both players over time. This tree is usually called a &lt;em&gt;game tree&lt;/em&gt; whose nodes are positions in a game and whose edges are moves. With this tree it is possible to solve the game using backward induction. Backward induction is an extremely powerful technique that has been applied not just to games but also to many other problems in computer science. It is sometimes known as Zermelo’s algorithm, named after Professor Ernst Zermelo, who used it to analyze the game of chess. The idea is very simple: to traverse the game tree in reverse order from leaves (endgame states) to the root (initial state) each time assuming the current move-making player is choosing what is best for himself. Here is a small example. Let’s assume that we are playing a television game show quiz. There is given a set of possible subjects, e.g. { Algebra, Biology, Chemistry, Drama}. Each participant in turn chooses a subject that he doesn’t want to answer and it disappears from the list. For example, there are 3 players with their own preferences (in descending order):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;th style=&#34;height: 24px; text-align: center;&#34;&gt;Player 1&lt;/th&gt;
&lt;th style=&#34;height: 24px; text-align: center;&#34;&gt;Player 2&lt;/th&gt;
&lt;th style=&#34;height: 24px; text-align: center;&#34;&gt;Player 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;C&lt;/td&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 19px;&#34;&gt;
&lt;td style=&#34;height: 19px; text-align: center;&#34;&gt;B&lt;/td&gt;
&lt;td style=&#34;height: 19px; text-align: center;&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;height: 19px; text-align: center;&#34;&gt;B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;C&lt;/td&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;B&lt;/td&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;D&lt;/td&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;D&lt;/td&gt;
&lt;td style=&#34;height: 24px; text-align: center;&#34;&gt;A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;the-straightforward-way&#34;&gt;The straightforward way&lt;/h3&gt;
&lt;p&gt;First of all lets try to solve the situation in a straightforward manner. So, &lt;strong&gt;Player 1&lt;/strong&gt; is getting rid of subject &lt;strong&gt;D&lt;/strong&gt;, &lt;strong&gt;Player 2&lt;/strong&gt; – &lt;strong&gt;B&lt;/strong&gt; (&lt;strong&gt;D&lt;/strong&gt; is already removed), &lt;strong&gt;Player 3&lt;/strong&gt; – &lt;strong&gt;A&lt;/strong&gt;. The result is – &lt;strong&gt;C&lt;/strong&gt; (Chemistry), which is not so good for &lt;strong&gt;Player 1&lt;/strong&gt;. Now let’s solve it the other way.&lt;/p&gt;
&lt;h3 id=&#34;backward-induction&#34;&gt;Backward induction&lt;/h3&gt;
&lt;p&gt;First we need to build a complete game tree. 
&lt;a href=&#34;./gametree.svg&#34;&gt;&lt;img src=&#34;./gametree.svg&#34; alt=&#34;&#34;&gt;&lt;/a&gt; Then, assuming the fact that &lt;strong&gt;Player 3&lt;/strong&gt;, who is making the last choice, always chooses what is best for himself, the tree can be reduced to the following 
&lt;a href=&#34;./gametree1.svg&#34;&gt;&lt;img src=&#34;./gametree1.svg&#34; alt=&#34;&#34;&gt;&lt;/a&gt; The same assumption for &lt;strong&gt;Player 2&lt;/strong&gt; 
&lt;a href=&#34;./gametree2.svg&#34;&gt;&lt;img src=&#34;./gametree2.svg&#34; alt=&#34;&#34;&gt;&lt;/a&gt; When the tree is fully reduced we can see that &lt;strong&gt;Player 1&lt;/strong&gt; is really choosing only between &lt;strong&gt;B&lt;/strong&gt; and &lt;strong&gt;C&lt;/strong&gt; and furthermore if he wants to get a better result in the end he has to sacrifice a better option in the beginning.&lt;/p&gt;
&lt;h2 id=&#34;coding&#34;&gt;Coding&lt;/h2&gt;
&lt;p&gt;Now back to our problem. Let’s code the backward induction algorithm using java this time. First, we need to store the changing state of the game.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.ArrayList;
import java.util.List;

public class State {
    private int stoneCount;

    public State(int stoneCount) {
        this.stoneCount = stoneCount;
    }

    public List&amp;lt;State&amp;gt; getNextStates() {
        List&amp;lt;State&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(3);
        result.add(new State(stoneCount - 1));
        result.add(new State(stoneCount - 2));
        result.add(new State(stoneCount - 3));
        return result;
    }

    public int getStoneCount() {
        return stoneCount;
    }

    public boolean isTerminated() {
        return stoneCount &amp;lt;= 3;
    }

    @Override
    public String toString() {
        return String.valueOf(stoneCount);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then the game tree. Each node contains the current state, boolean field that shows if the current player is able to win in the current state, and the next state that will come after the chosen move.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Node {
    private State state;
    private boolean currentPlayerWins;
    private Node nextNode;

    public Node(State state) {
        this.state = state;
    }

    public State getState() {
        return state;
    }

    public boolean getCurrentPlayerWins() {
        return currentPlayerWins;
    }

    public void setCurrentPlayerWins(boolean currentPlayerWins) {
        this.currentPlayerWins = currentPlayerWins;
    }

    public void setNextNode(Node nextNode) {
        this.nextNode = nextNode;
    }

    @Override
    public String toString() {
        String result = String.format(&amp;quot;{%s | %s}&amp;quot;, state, currentPlayerWins);

        if (nextNode != null) {
            result += String.format(&amp;quot; -&amp;gt; %s&amp;quot;, nextNode);
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last thing that we need is the worker that will build and reduce the game tree. Here we need to do some tricks. First of all don’t try to store the complete tree in memory, because you will need to allocate &lt;strong&gt;56343125079040471808818753&lt;/strong&gt; nodes. I bet that you will run out of memory pretty soon. Instead, we might generate only the winning subtrees, because a single winning subnode is enough to treat the previous node as winning. Another thing is that though the amount of nodes is enormous, the amount of possible states is limited to between 1 and 99, and no matter how you get to it either straight from 99 to 96, or following the path 99 -&amp;gt; 98 -&amp;gt; 96, if the current player is able to win from state 96 in the first branch, he wins from this state in the second. So, cache can be used to store results for states that have already been calculated.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TreeWorker {
    private final Map&amp;lt;Integer, Node&amp;gt; cache = new HashMap&amp;lt;&amp;gt;();

    public Node generateTree(State initialState) {
        Node root = new Node(initialState);
        generateSubTree(root);
        return root;
    }

    private void generateSubTree(Node node) {
        if (node.getState().isTerminated()) {
            node.setCurrentPlayerWins(true);
            return;
        }

        Node nextNode = null;
        List&amp;lt;State&amp;gt; states = node.getState().getNextStates();
        Collections.shuffle(states);
        for (State state : states) {
            nextNode = cache.get(state.getStoneCount());
            if (nextNode == null) {
                nextNode = new Node(state);
                generateSubTree(nextNode);

                cache.put(nextNode.getState().getStoneCount(), nextNode);
            }

            if (!nextNode.getCurrentPlayerWins()) {
                break;
            }
        }

        node.setCurrentPlayerWins(!nextNode.getCurrentPlayerWins());
        node.setNextNode(nextNode);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the second game (with powers of 2) we need to slightly modify the &lt;code&gt;State&lt;/code&gt; class&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.ArrayList;
import java.util.List;

public class State {
    private int stoneCount;

    public State(int stoneCount) {
        this.stoneCount = stoneCount;
    }

    public List&amp;lt;State&amp;gt; getNextStates() {
        List&amp;lt;State&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        int cnt = 1;
        while (cnt &amp;lt;= stoneCount) {
            result.add(new State(stoneCount - cnt));
            cnt = cnt &amp;lt;&amp;lt; 1;
        }
        return result;
    }

    public int getStoneCount() {
        return stoneCount;
    }

    public boolean isTerminated() {
        int cnt = 1;
        while (cnt &amp;lt; stoneCount) {
            cnt = cnt &amp;lt;&amp;lt; 1;
        }

        return cnt == stoneCount;
    }

    @Override
    public String toString() {
        return String.valueOf(stoneCount);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-result&#34;&gt;The result&lt;/h2&gt;
&lt;p&gt;Now run the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TreeWorker worker = new TreeWorker();
Node root = worker.generateTree(new State(99));

System.out.println(root);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will give an output similar to this for the first game: &lt;code&gt;{99 | true} -&amp;gt; {96 | false} -&amp;gt; {93 | true} -&amp;gt; {92 | false} -&amp;gt; {91 | true} -&amp;gt; {88 | false} -&amp;gt; {85 | true} -&amp;gt; {84 | false} -&amp;gt; {81 | true} -&amp;gt; {80 | false} -&amp;gt; {77 | true} -&amp;gt; {76 | false} -&amp;gt; {75 | true} -&amp;gt; {72 | false} -&amp;gt; {69 | true} -&amp;gt; {68 | false} -&amp;gt; {67 | true} -&amp;gt; {64 | false} -&amp;gt; {63 | true} -&amp;gt; {60 | false} -&amp;gt; {58 | true} -&amp;gt; {56 | false} -&amp;gt; {55 | true} -&amp;gt; {52 | false} -&amp;gt; {51 | true} -&amp;gt; {48 | false} -&amp;gt; {46 | true} -&amp;gt; {44 | false} -&amp;gt; {42 | true} -&amp;gt; {40 | false} -&amp;gt; {37 | true} -&amp;gt; {36 | false} -&amp;gt; {33 | true} -&amp;gt; {32 | false} -&amp;gt; {30 | true} -&amp;gt; {28 | false} -&amp;gt; {25 | true} -&amp;gt; {24 | false} -&amp;gt; {21 | true} -&amp;gt; {20 | false} -&amp;gt; {18 | true} -&amp;gt; {16 | false} -&amp;gt; {13 | true} -&amp;gt; {12 | false} -&amp;gt; {11 | true} -&amp;gt; {8 | false} -&amp;gt; {7 | true} -&amp;gt; {4 | false} -&amp;gt; {3 | true}&lt;/code&gt; So, it seems that the first player has the winning strategy and will win from the initial position if he performs a perfect play. In this case the second player is desperate – having &lt;code&gt;false&lt;/code&gt; in each of his moves shows the absence of moves leading to a victory. It is not hard to notice the pattern. Each time the second player takes 1 stone out of the pile, the first takes out 3 stones; for 2 stones – 2 stones; and for 3 stones – 1 stone. So the idea is quite clear – to win one has to keep the number of stones divisible by 4. For the second game the output is somewhat similar to the following: &lt;code&gt;{99 | false} -&amp;gt; {98 | true} -&amp;gt; {66 | false} -&amp;gt; {58 | true} -&amp;gt; {54 | false} -&amp;gt; {46 | true} -&amp;gt; {30 | false} -&amp;gt; {14 | true} -&amp;gt; {6 | false} -&amp;gt; {2 | true}&lt;/code&gt; So, here the situation is totally different and the first player cannot win if both sides perform a perfect play. The strategy is to keep the number of stones divisible by 3.&lt;/p&gt;
&lt;h2 id=&#34;outro&#34;&gt;Outro&lt;/h2&gt;
&lt;p&gt;Zermelo’s backward induction algorithm is one of the cornerstone algorithms in game theory. It is a classic example of dynamic programming, in which a solution to an overall problem is systematically built up from the solutions to smaller problems. It can be used to analyze different games from tic-tac-toe to chess. So, try it your own!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reducing the size of MongoDB document in c#</title>
      <link>/post/reducing-the-size-of-mongodb-document-in-cs/</link>
      <pubDate>Sat, 15 Apr 2017 14:17:00 +0300</pubDate>
      <guid>/post/reducing-the-size-of-mongodb-document-in-cs/</guid>
      <description>&lt;p&gt;Storing data in MongoDB with the official C# driver sooner or later you might run into the following exception:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.IO.FileFormatException: Size 22327168 is larger than MaxDocumentSize 16777216.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is happening because of the limitation of a single document size that exists in MongoDB by design.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The maximum BSON document size is 16 megabytes. The maximum document size helps ensure that a single document cannot use excessive amount of RAM or, during transmission, excessive amount of bandwidth.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Though there is a JIRA ticket called 
&lt;a href=&#34;https://jira.mongodb.org/browse/SERVER-5923&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Increase max document size to at least 64mb&lt;/a&gt;, it doesn’t seem likely to be done in the near future. Geert Bosch, senior software engineer at MongoDB, wrote the following comment:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In order to support much larger documents, such as the 64Mb documents suggested, assumptions such as that we can easily allocate copies of documents for modification will no longer hold. Transactions could grow extremely large (just think of a 64Mb array of elements to index). We would need to significantly throttle the number of concurrent operations, or raise the memory requirements for mongod.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But, if you find yourself stuck in such a situation, don’t get frustrated – there is a solution.&lt;/p&gt;
&lt;h2 id=&#34;explore-the-document&#34;&gt;Explore the document&lt;/h2&gt;
&lt;p&gt;MongoDB uses JSON documents in order to store records, but stores them in a binary-encoded format called BSON. Take a look at your document. It might look somewhat similar to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;Property1&amp;quot;: true,
  &amp;quot;Property2&amp;quot;: 123,
  &amp;quot;Property3&amp;quot;: &amp;quot;Hello World&amp;quot;,
  &amp;quot;Property4&amp;quot;: null,
  &amp;quot;Property5&amp;quot;: null,
  &amp;quot;Property6&amp;quot;: [
    1,
    2,
    3
  ],
  &amp;quot;Property7&amp;quot;: []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With an object-oriented representation like .net objects usually store their name and the &lt;code&gt;null&lt;/code&gt; literal for each null property. Also you may notice empty arrays. Another thing that may be tuned is the property name mapping. By default, the names of the fields in the generated JSON document are equal to those of the corresponding properties. So, the solution is to get rid of everything that is possible and shorten the names.&lt;/p&gt;
&lt;h2 id=&#34;the-solution&#34;&gt;The solution&lt;/h2&gt;
&lt;h3 id=&#34;ignoring-null-values&#34;&gt;Ignoring null values&lt;/h3&gt;
&lt;p&gt;To ignore the null values you have at least 3 options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;decorating properties with BsonIgnoreIfNull attribute&lt;/li&gt;
&lt;li&gt;using fluent api&lt;/li&gt;
&lt;li&gt;register a global convention&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first option lets you mark properties individually:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public class Class1
{
    public bool Property1 { get; set; }
    public int Property2 { get; set; }
	[BsonIgnoreIfNull]
    public string Property3 { get; set; }
	[BsonIgnoreIfNull]
    public string Property4 { get; set; }
	[BsonIgnoreIfNull]
    public string Property5 { get; set; }
	[BsonIgnoreIfNull]
    public List&amp;lt;int&amp;gt; Property6 { get; set; }
	[BsonIgnoreIfNull]
    public List&amp;lt;int&amp;gt; Property7 { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But it is better to keep your business entities clean, so consider the second option.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Class1&amp;gt;(x =&amp;gt;
{
     x.AutoMap();
     x.GetMemberMap(m =&amp;gt; m.Property3).SetIgnoreIfNull(true);
     x.GetMemberMap(m =&amp;gt; m.Property4).SetIgnoreIfNull(true);
     x.GetMemberMap(m =&amp;gt; m.Property5).SetIgnoreIfNull(true);
     x.GetMemberMap(m =&amp;gt; m.Property6).SetIgnoreIfNull(true);
     x.GetMemberMap(m =&amp;gt; m.Property7).SetIgnoreIfNull(true);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But still it can add a lot of code, so you might want to introduce a global policy.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;ConventionRegistry.Register(
	&amp;quot;Ignore null values&amp;quot;,
	new ConventionPack
	{
		new IgnoreIfNullConvention(true)
	},
	t =&amp;gt; t == typeof(Class1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last predicate ensures the policy only applies to &lt;code&gt;Class1&lt;/code&gt; class. Also make sure you are registering the new convention pack early enough. If the class has already been mapped it won’t be updated.&lt;/p&gt;
&lt;h3 id=&#34;ignoring-empty-collections&#34;&gt;Ignoring empty collections&lt;/h3&gt;
&lt;p&gt;It is not complicated to do with the &lt;code&gt;SetShouldSerializeMethod&lt;/code&gt;. The specified predicate is triggered to determine whether the member should be serialized. Simply check the number of items inside the collection before saving it. Here is the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Class1&amp;gt;(x =&amp;gt;
{
     x.AutoMap();
     x.GetMemberMap(m =&amp;gt; m.Property7).SetShouldSerializeMethod(x =&amp;gt; ((Class1)x).Property7.Count &amp;gt; 0);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shortening-names&#34;&gt;Shortening names&lt;/h3&gt;
&lt;p&gt;The last and probably the most efficient way is to make each class property name shorter. Of course it affects your data readability, that is why it is not the first offered solution, but in my case it reduced the document size by two times. As usual you can use an attribute or a fluent approach. The attribute is called &lt;code&gt;BsonElement.&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public class Class1
{
	[BsonElement(&amp;quot;p1&amp;quot;)]
    public bool Property1 { get; set; }
	[BsonElement(&amp;quot;p2&amp;quot;)]
    public int Property2 { get; set; }
	[BsonElement(&amp;quot;p3&amp;quot;)]
    public string Property3 { get; set; }	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following code can be used with the fluent api&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Class1&amp;gt;(x =&amp;gt;
{
     x.AutoMap();
	 x.GetMemberMap(m =&amp;gt; m.Property4).SetElementName(&amp;quot;p4&amp;quot;);
	 x.GetMemberMap(m =&amp;gt; m.Property5).SetElementName(&amp;quot;p5&amp;quot;);
	 x.GetMemberMap(m =&amp;gt; m.Property6).SetElementName(&amp;quot;p6&amp;quot;);
     x.GetMemberMap(m =&amp;gt; m.Property7).SetElementName(&amp;quot;p7&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;result&#34;&gt;Result&lt;/h2&gt;
&lt;p&gt;After applying this solution you might be able to get a document that fits into the MongoDB database. Compared to the original document the result seems to save a lot of space. Consider the resulting JSON&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{
  &amp;quot;p1&amp;quot;: true,
  &amp;quot;p2&amp;quot;: 123,
  &amp;quot;p3&amp;quot;: &amp;quot;Hello World&amp;quot;,
  &amp;quot;p6&amp;quot;: [
    1,
    2,
    3
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think that the difference in size is obvious. Using all three techniques allowed me to store a document that seemed too large in the beginning.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go-linq v3.0: Emulating generics in Go</title>
      <link>/post/go-linq-v3-0-emulating-generics-in-go/</link>
      <pubDate>Fri, 24 Feb 2017 20:37:00 +0300</pubDate>
      <guid>/post/go-linq-v3-0-emulating-generics-in-go/</guid>
      <description>&lt;p&gt;About a month ago we welcomed a new developer to our go-linq maintainers team 
&lt;a href=&#34;https://github.com/cleitonmarx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cleitonmarx&lt;/a&gt; (Cleiton Marques) who introduced an interesting pattern for emulating generics in Go and became the main show-maker of the third version of the library. Here is a small story of how the generics behavior was emulated in go-linq.&lt;/p&gt;
&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;
&lt;p&gt;Being one of the most requested features in Go language for years, the question of generics has been discussed up and down and back and forth. For now it seems that they won&amp;rsquo;t appear in the near future. In fact, the language designers aren&amp;rsquo;t against generics, but they have not found or seen a good proposal that allows generics in the language without significantly complicating it. Anyway, we got used to living without generics. This resulted in a slight adjustment to our way of thinking and brought to life tons of elegant solutions. But sometimes there are situations when generics are indispensable. For example, in the go-linq library methods are intended to be used with delegates of any data type, so we made them accept functions of empty interfaces. This interface has no particular behavior, hence objects with any behavior satisfy this interface and the end user of the library is responsible for doing the right type casts. Despite its good performance, this approach isn&amp;rsquo;t use-of-wrong-data-type proof and looks clumsy. Consider the difference:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;From(cars).Where(func(c interface{}) bool {
    return c.(Car).year &amp;gt;= 2015
}).Select(func(c interface{}) interface{} {
    return c.(Car).owner
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vs&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;From(cars).Where(func(c Car) bool {
    return c.year &amp;gt;= 2015
}).Select(func(c Car) string {
    return c.owner
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and it&amp;rsquo;s getting worse depending on the complexity of your code. So, we introduced a pattern for emulating/improving generics-like methods in our library that uses the reflection mechanism internally and make your code look much easier to read and understand.&lt;/p&gt;
&lt;h2 id=&#34;the-solution&#34;&gt;The solution&lt;/h2&gt;
&lt;p&gt;The idea is to make a new method that wraps around the original one with empty interfaces and does all the casts automatically using reflection. The second part of the solution comes from the fact that the signature to the new method is &lt;code&gt;func (q Query) WhereT(predicateFn interface{}) Query&lt;/code&gt; , so anything can be specified as the argument and we need a way to validate it.&lt;/p&gt;
&lt;p&gt;First, let&amp;rsquo;s define a structure to store all the necessary data:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type functionCache struct {
	MethodName string
	ParamName  string
	FnValue    reflect.Value
	FnType     reflect.Type
	TypesIn    []reflect.Type
	TypesOut   []reflect.Type
}

type genericFunc struct {
	Cache *functionCache
}

func (g *genericFunc) Call(params ...interface{}) interface{} {
 paramsIn := make([]reflect.Value, len(params))
 for i, param := range params {
 paramsIn[i] = reflect.ValueOf(param)
 }
 paramsOut := g.Cache.FnValue.Call(paramsIn)
 if len(paramsOut) &amp;gt;= 1 {
 return paramsOut[0].Interface()
 }
 return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MethodName&lt;/code&gt; and &lt;code&gt;ParamName&lt;/code&gt; are used in error handling to form a reasonable message. &lt;code&gt;TypesIn&lt;/code&gt; and &lt;code&gt;TypesOut&lt;/code&gt; store respectively the input and output parameters of the specified function.&lt;/p&gt;
&lt;p&gt;Secondly, we need a factory method for the &amp;lsquo;genericFunc&amp;rsquo;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func newGenericFunc(methodName, paramName string,
	fn interface{},
	validateFunc func(*functionCache) error) (*genericFunc, error) {

	cache := &amp;amp;functionCache{}
	cache.FnValue = reflect.ValueOf(fn)

	if cache.FnValue.Kind() != reflect.Func {
		return nil,
			fmt.Errorf(&amp;quot;%s: parameter [%s] is not a function type. It is a &#39;%s&#39;&amp;quot;,
				methodName, paramName, cache.FnValue.Type())
	}
	cache.MethodName = methodName
	cache.ParamName = paramName
	cache.FnType = cache.FnValue.Type()
	numTypesIn := cache.FnType.NumIn()
	cache.TypesIn = make([]reflect.Type, numTypesIn)
	for i := 0; i &amp;lt; numTypesIn; i++ {
		cache.TypesIn[i] = cache.FnType.In(i)
	}

	numTypesOut := cache.FnType.NumOut()
	cache.TypesOut = make([]reflect.Type, numTypesOut)
	for i := 0; i &amp;lt; numTypesOut; i++ {
		cache.TypesOut[i] = cache.FnType.Out(i)
	}
	if err := validateFunc(cache); err != nil {
		return nil, err
	}

	return &amp;amp;genericFunc{Cache: cache}, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;it populates the &lt;code&gt;genericFunc&lt;/code&gt; structure and validates it. The validation function must be provided by the user of the method, but we have a helper to produce it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func simpleParamValidator(In []reflect.Type, Out []reflect.Type) func(cache *functionCache) error {
	return func(cache *functionCache) error {
		var isValid = func() bool {
			if In != nil {
				if len(In) != len(cache.TypesIn) {
					return false
				}
				for i, paramIn := range In {
					if paramIn != genericTp &amp;amp;&amp;amp; paramIn != cache.TypesIn[i] {
						return false
					}
				}
			}
			if Out != nil {
				if len(Out) != len(cache.TypesOut) {
					return false
				}
				for i, paramOut := range Out {
					if paramOut != genericTp &amp;amp;&amp;amp; paramOut != cache.TypesOut[i] {
						return false
					}
				}
			}
			return true
		}

		if !isValid() {
			return fmt.Errorf(
				&amp;quot;%s: parameter [%s] has a invalid function signature. Expected: &#39;%s&#39;, actual: &#39;%s&#39;&amp;quot;,
				cache.MethodName,
				cache.ParamName,
				formatFnSignature(In, Out),
				formatFnSignature(cache.TypesIn, cache.TypesOut))
		}
		return nil
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last thing we need is the wrapper around the original method that does all the magic. For the above-mentioned &lt;code&gt;Where&lt;/code&gt; method it is as simple as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (q Query) WhereT(predicateFn interface{}) Query {

	predicateGenericFunc, err := newGenericFunc(
		&amp;quot;WhereT&amp;quot;, &amp;quot;predicateFn&amp;quot;, predicateFn,
		simpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),
	)
	if err != nil {
		panic(err)
	}

	predicateFunc := func(item interface{}) bool {
		return predicateGenericFunc.Call(item).(bool)
	}

	return q.Where(predicateFunc)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, you provide a function with your custom types to a new &lt;code&gt;WhereT&lt;/code&gt; method and it produces a wrapper with empty interfaces that will suffice for the original method &lt;code&gt;Where&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-test&#34;&gt;The test&lt;/h2&gt;
&lt;p&gt;If you are writing unit tests on your project and are pursuing a 100% coverage level, as we do in go-linq, then it is not an easy task to achieve with this pattern. After trying several approaches we ended up with writing several tests:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one for the right case when everything is ok&lt;/li&gt;
&lt;li&gt;and the second that tests the validation, recovers the panic and checks the error message.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestWhereT_PanicWhenPredicateFnIsInvalid(t *testing.T) {
	mustPanicWithError(
		t,
		&amp;quot;WhereT: parameter [predicateFn] has a invalid function signature. Expected: &#39;func(T)bool&#39;, actual: &#39;func(int)int&#39;&amp;quot;,
		func() {
			From([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).WhereT(func(item int) int { return item + 2 })
		})
}

func mustPanicWithError(t *testing.T, expectedErr string, f func()) {
	defer func() {
		r := recover()
		err := fmt.Sprintf(&amp;quot;%s&amp;quot;, r)
		if err != expectedErr {
			t.Fatalf(&amp;quot;got=[%v] expected=[%v]&amp;quot;, err, expectedErr)
		}
	}()
	f()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-downsides&#34;&gt;The downsides&lt;/h2&gt;
&lt;p&gt;The first and probably the main downside of this solution is the performance penalty. Running the same scenarios that I used in one of the previous articles 
&lt;a href=&#34;/2016/07/16/manipulating-data-with-iterators-in-go/&#34;&gt;Manipulating data with iterators in Go&lt;/a&gt; we can see that this approach is around 5x-10x slower. That is why we decided to provide users with both versions of the methods leaving the original as is and calling the new ones by the &lt;em&gt;-T&lt;/em&gt; naming convention.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BenchmarkSelectWhereFirst-4              5000000               352 ns/op
BenchmarkSelectWhereFirst_generics-4     1000000              2094 ns/op
BenchmarkSum-4                                50          37427788 ns/op
BenchmarkSum_generics-4                        3         360509066 ns/op
BenchmarkZipSkipTake-4                  10000000               224 ns/op
BenchmarkZipSkipTake_generics-4          1000000              1265 ns/op
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second issue comes from the signature of the &lt;em&gt;-T method&lt;/em&gt;, as you can see it accepts an empty interface, i.e. &lt;code&gt;predicateFn&lt;/code&gt; can be literally anything.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;decode:true&amp;quot;&amp;gt;func (q Query) WhereT(predicateFn interface{}) Query
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, a user of the method can have problems understanding what &lt;code&gt;predicateFn&lt;/code&gt; should look like, especially if he is new to the library. We conducted a long discussion to deal with the problem and ended up with the idea that the best we can do is to provide really good documentation and examples of each method (thanks 
&lt;a href=&#34;http://www.cleitonmarques.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cleiton&lt;/a&gt; for being so patient and hardworking).&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Do I need generics in Go? Not really, especially with the new 
&lt;a href=&#34;https://blog.golang.org/generate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go:generate&lt;/a&gt; feature. But if you still need them, there is always a way to emulate generic behavior even though it isn&amp;rsquo;t supported by the language, either by using empty interfaces and maintaining good performance, or with the pattern shown above making the code cleaner, more readable and free of type assertions. &lt;strong&gt;Note.&lt;/strong&gt; The full source code is available in 
&lt;a href=&#34;https://github.com/ahmetalpbalkan/go-linq/blob/master/genericfunc.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;genericfunc.go&lt;/a&gt; in our repository. Please, feel free to ask any questions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How to copy tags from one git repository to another</title>
      <link>/post/how-to-copy-tags-from-one-git-repository-to-another/</link>
      <pubDate>Wed, 22 Feb 2017 17:17:55 +0300</pubDate>
      <guid>/post/how-to-copy-tags-from-one-git-repository-to-another/</guid>
      <description>&lt;p&gt;Not long ago my team moved a legacy version of our application from a different branch out into a new repository. The problem was that they had forgotten to copy tags there, so we lived without tags for quite a time, until I decided to deal with the problem and made a utility that copies matching tags from one git repository to another.&lt;/p&gt;
&lt;p&gt;Actually, I found a solution on 
&lt;a href=&#34;https://github.com/foghina/git-copy-tags&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github&lt;/a&gt; which was a shell script written in ruby. But there were two issues. First, I neither had nor wanted to install ruby on my machine. Secondly, I use Windows on my office laptop. So, I decided to port the original script to Go and here is the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;os/exec&amp;quot;
	&amp;quot;runtime&amp;quot;
	&amp;quot;strings&amp;quot;
)

func usage() {
	fmt.Println(&amp;quot;Usage: git-copy-tags &amp;lt;source-repo&amp;gt; &amp;lt;dest-repo&amp;gt; [-f]&amp;quot;)
	fmt.Println(&amp;quot;By default, the script is in \&amp;quot;dry run\&amp;quot; mode, which means that it only prints out what it would do, without actually doing it. If you are happy with the result, add -f.&amp;quot;)
	os.Exit(1)
}

func shell(cmd string) ([]byte, error) {
	sh := &amp;quot;sh&amp;quot;
	c := &amp;quot;-c&amp;quot;
	if runtime.GOOS == &amp;quot;windows&amp;quot; {
		sh = &amp;quot;cmd&amp;quot;
		c = &amp;quot;/c&amp;quot;
	}

	return exec.Command(sh, c, cmd).CombinedOutput()
}

func exe(cmd string) string {
	result, err := shell(cmd)
	if err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	return string(result)
}

func getTags() map[string]string {
	tags := exe(&amp;quot;git tag&amp;quot;)
	dict := make(map[string]string)

	for _, tag := range strings.Split(tags, &amp;quot;\n&amp;quot;) {
		tag = strings.TrimSpace(tag)
		if len(tag) &amp;lt; 1 {
			continue
		}
		cmd := fmt.Sprintf(&amp;quot;git rev-list --max-count=1 %s&amp;quot;, tag)
		commit := strings.TrimSpace(exe(cmd))
		dict[tag] = commit
	}

	return dict
}

func main() {
	if len(os.Args) &amp;lt; 3 {
		usage()
	}

	src := os.Args[1]
	dest := os.Args[2]
	force := false
	if len(os.Args) &amp;gt; 3 &amp;amp;&amp;amp; os.Args[3] == &amp;quot;-f&amp;quot; {
		force = true
	}

	os.Chdir(src)
	srcTags := getTags()

	os.Chdir(dest)
	destTags := getTags()

	if !force {
		fmt.Println(&amp;quot;Running dry, use -f to actually apply changes...&amp;quot;)
	}

	for tag, commit := range srcTags {
		if _, ok := destTags[tag]; !ok {
			cmd := fmt.Sprintf(&amp;quot;git rev-list --max-count=1 %s&amp;quot;, commit)
			if _, err := shell(cmd); err == nil {
				if force {
					if _, err := shell(fmt.Sprintf(&amp;quot;git tag %s %s\n&amp;quot;, tag, commit)); err == nil {
						fmt.Printf(&amp;quot;Tagged %s with %s&amp;quot;, commit, tag)
					} else {
						fmt.Printf(&amp;quot;Error while tagging %s with %s\n&amp;quot;, commit, tag)
					}

				} else {
					fmt.Printf(&amp;quot;Would tag %s with %s\n&amp;quot;, commit, tag)
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git-copy-tags &amp;lt;source-repo&amp;gt; &amp;lt;dest-repo&amp;gt; \[-f\]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, the script is in &amp;ldquo;dry run&amp;rdquo; mode, which means that it only prints out what it would do, without actually doing it. If you are happy with the result, add -f.&lt;/p&gt;
&lt;p&gt;After running the command with -f, make sure to run &lt;code&gt;git push --tags&lt;/code&gt;  in the destination repository.&lt;/p&gt;
&lt;h2 id=&#34;download&#34;&gt;Download&lt;/h2&gt;
&lt;p&gt;The source code is available in the github 
&lt;a href=&#34;https://github.com/kalaninja/git-copy-tags&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repository&lt;/a&gt;. And here is a cross-compiled version for different operating systems (all 64-bit)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/kalaninja/git-copy-tags/releases/download/release/git-copy-tags.exe&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/kalaninja/git-copy-tags/releases/download/release/darwin.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MacOSX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/kalaninja/git-copy-tags/releases/download/release/linux.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bonus-cross-compilation-in-go&#34;&gt;Bonus. Cross compilation in Go&lt;/h2&gt;
&lt;p&gt;Since Go 1.5 cross compilation is very simple. Just properly set a pair of &lt;code&gt;$GOOS&lt;/code&gt; and &lt;code&gt;$GOARCH&lt;/code&gt; variables and run a build process as usual. For example, on Windows it can be done in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;set GOARCH=amd64
set GOOS=linux
go build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The actual list is defined in 
&lt;a href=&#34;https://github.com/golang/go/blob/master/src/go/build/syslist.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;src/go/build/syslist.go&lt;/a&gt; and the valid combinations of &lt;code&gt;$GOOS&lt;/code&gt; and &lt;code&gt;$GOARCH&lt;/code&gt; are:&lt;/p&gt;
&lt;table cellpadding=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34; width=&#34;100&#34;&gt;$GOOS&lt;/th&gt;
&lt;th align=&#34;left&#34; width=&#34;100&#34;&gt;$GOARCH&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;android&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;arm64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;arm64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;ppc64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;ppc64le&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;mips&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;mipsle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;mips64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;mips64le&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;solaris&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>Announcement: go2linq is now in the go-linq repository</title>
      <link>/post/announcement-go2linq-is-now-in-the-go-linq-repository/</link>
      <pubDate>Sat, 10 Sep 2016 17:22:00 +0300</pubDate>
      <guid>/post/announcement-go2linq-is-now-in-the-go-linq-repository/</guid>
      <description>&lt;p&gt;I am happy to announce that my 
&lt;a href=&#34;https://github.com/kalaninja/go2linq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go2linq&lt;/a&gt; (a powerful language integrated query (LINQ) library for Go) project has been merged into the 
&lt;a href=&#34;https://github.com/ahmetalpbalkan/go-linq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-linq&lt;/a&gt;&amp;rsquo;s master branch. Now it is available as the newest version of 
&lt;a href=&#34;http://ahmetalpbalkan.github.io/go-linq/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-linq&lt;/a&gt; library (v2.0.0).&lt;/p&gt;
&lt;p&gt;All further development will be conducted in the new repository and go2linq will remain only for compatibility reasons. &lt;strong&gt;Please, do not use it anymore!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I would like to thank 
&lt;a href=&#34;https://ahmetalpbalkan.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ahmet Alp Balkan&lt;/a&gt; who has made me the maintainer of the go-linq repository and is cooperating in the further development.&lt;/p&gt;
&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;go-linq website: 
&lt;a href=&#34;http://ahmetalpbalkan.github.io/go-linq/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://ahmetalpbalkan.github.io/go-linq/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github repository: 
&lt;a href=&#34;https://github.com/ahmetalpbalkan/go-linq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/ahmetalpbalkan/go-linq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;godoc: 
&lt;a href=&#34;https://godoc.org/github.com/ahmetalpbalkan/go-linq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://godoc.org/github.com/ahmetalpbalkan/go-linq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Solving a payment without change problem</title>
      <link>/post/solving-a-payment-without-change-problem/</link>
      <pubDate>Sat, 30 Jul 2016 23:21:00 +0300</pubDate>
      <guid>/post/solving-a-payment-without-change-problem/</guid>
      <description>&lt;p&gt;I have come across an interesting problem. A customer is standing at the checkout of a grocery store with his purchases and is asked to pay the exact amount without creating any change. There are notes of various denominations  in his pockets in random order (note denomination is not tied to a real bank notes, the only boundary is that it is an integer greater than 0). The objective is to pick up the necessary sum or indicate that it is not possible. If several solutions are possible then any of them is acceptable. So, let&amp;rsquo;s solve it using C# language.&lt;/p&gt;
&lt;p&gt;This problem is a special case of the knapsack problem (given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible) and is equivalent to a subset sum problem (finding a non-empty subset whose sum is zero) with an extra condition that each element of the set is strictly greater than zero. As it is an NP-complete problem I can think of 2 possible ways to solve it. Let&amp;rsquo;s first discuss the recursive approach and then improve it using dynamic programming.&lt;/p&gt;
&lt;h2 id=&#34;recursive-approach&#34;&gt;Recursive Approach&lt;/h2&gt;
&lt;p&gt;This is the most naive algorithm. For every element in the set there are two options, either we will include that element in the subset or we won’t include it. Then cycle through all these subsets and, for every one of them, check if the subset sum equals the right number. This solution is quite similar to &lt;em&gt;generating all strings of n bits&lt;/em&gt; and its time complexity is as high as_ O(n*2n)_, since there are _2n_ subsets and for each subset we need to sum _n_ elements.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s improve it a bit. First optimization comes from the idea that we do not really need to calculate all the possible subsets and calculate all the sums afterward. Instead we can merge these two steps in a single operation and have a means to restore the set that produced the right sum. Having a set &lt;em&gt;A&lt;/em&gt; of elements &lt;em&gt;{a1, a2, a3 &amp;hellip; an}&lt;/em&gt; let&amp;rsquo;s build a tree of all possible sums until we find a target sum &lt;em&gt;S&lt;/em&gt;. Let&amp;rsquo;s start with adding 0 to the tree and then adding each element of &lt;em&gt;A&lt;/em&gt; to all the elements in this tree.&lt;/p&gt;
&lt;table style=&#34;width: 548px;&#34;&gt;
&lt;tbody&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;text-align: center; width: 38px; height: 24px;&#34;&gt;&lt;em&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 52px; height: 24px;&#34;&gt;&lt;em&gt;&lt;strong&gt;a&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 75px; height: 24px;&#34;&gt;&lt;em&gt;&lt;strong&gt;a&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 114px; height: 24px;&#34;&gt;&lt;em&gt;&lt;strong&gt;a&lt;sub&gt;3&lt;/sub&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 42px; height: 24px;&#34;&gt;&lt;em&gt;&lt;strong&gt;...&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 191px; height: 24px;&#34;&gt;&lt;em&gt;&lt;strong&gt;a&lt;sub&gt;n&lt;/sub&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;text-align: center; width: 38px; height: 24px;&#34;&gt;&lt;em&gt;0&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 52px; height: 24px;&#34;&gt;&lt;em&gt;0+a&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 75px; height: 24px;&#34;&gt;&lt;em&gt;0+a&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 114px; height: 24px;&#34;&gt;&lt;em&gt;0+a&lt;sub&gt;3&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 42px; height: 24px;&#34;&gt;&lt;em&gt;...&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 191px; height: 24px;&#34;&gt;&lt;em&gt;0+a&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;text-align: center; width: 38px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 52px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 75px; height: 24px;&#34;&gt;&lt;em&gt;(0+a&lt;sub&gt;1&lt;/sub&gt;)+a&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 114px; height: 24px;&#34;&gt;&lt;em&gt;(0+a&lt;sub&gt;1&lt;/sub&gt;)+a&lt;sub&gt;3&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 42px; height: 24px;&#34;&gt;&lt;em&gt;... &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 191px; height: 24px;&#34;&gt;&lt;em&gt;(0+a&lt;sub&gt;1&lt;/sub&gt;)+a&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;text-align: center; width: 38px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 52px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 75px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 114px; height: 24px;&#34;&gt;&lt;em&gt;(0+a&lt;sub&gt;2&lt;/sub&gt;)+a&lt;sub&gt;3&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 42px; height: 24px;&#34;&gt;&lt;em&gt;... &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 191px; height: 24px;&#34;&gt;&lt;em&gt;(0+a&lt;sub&gt;2&lt;/sub&gt;)+a&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;text-align: center; width: 38px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 52px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 75px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 114px; height: 24px;&#34;&gt;&lt;em&gt;((0+a&lt;sub&gt;1&lt;/sub&gt;)+a&lt;sub&gt;2&lt;/sub&gt;)+a&lt;sub&gt;3&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 42px; height: 24px;&#34;&gt;&lt;em&gt;...&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 191px; height: 24px;&#34;&gt;&lt;em&gt;((0+a&lt;sub&gt;1&lt;/sub&gt;)+a&lt;sub&gt;2&lt;/sub&gt;)+a&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;text-align: center; width: 38px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 52px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 75px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 114px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 42px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 191px; height: 24px;&#34;&gt;&lt;em&gt;…&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&#34;height: 24px;&#34;&gt;
&lt;td style=&#34;text-align: center; width: 38px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 52px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 75px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 114px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 42px; height: 24px;&#34;&gt;&lt;em&gt; &lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 191px; height: 24px;&#34;&gt;&lt;em&gt;(((0+a&lt;sub&gt;1&lt;/sub&gt;)+a&lt;sub&gt;2&lt;/sub&gt;)+a&lt;sub&gt;3&lt;/sub&gt;)+…+a&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As you can see now, no extra step is needed to sum each subset, instead each level of the tree uses sums from the previous tiers. So, there is 1 sum for the 1st element, 2 sums for the 2nd, 4 sums for the 3rd, 8 sums for the 4th, etc. This forms a geometrical progression with the total of $$\frac {1(1-2^n)}{1-2} = 2^n-1$$ elements. Now this method&amp;rsquo;s complexity is &lt;em&gt;O(2n)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Secondly, we can utilize the boundary condition. As we know that all the elements in the set are positive, it is obvious that adding a new element to the set only increases the current sum. So, if the current sum of the node is higher than the target sum this solution becomes rejected and is not used in further computations. This decreases the complexity to &lt;em&gt;O(2n) in the worst case&lt;/em&gt;. Also we can benefit from sorting the set in the descending order, because this will help to reject more solutions in the early stage. Here is the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static List&amp;lt;int&amp;gt; FindRecursive(int[] set, int targetSum, int currentSum, int currentIndex)
{
	for (var i = currentIndex; i &amp;lt; set.Length; i++)
	{
		var newSum = currentSum + set[i];
		if (newSum &amp;gt; targetSum)
		{
			continue;
		}

		if (newSum == targetSum)
		{
			return new List&amp;lt;int&amp;gt; { set[i] };
		}

		var result = FindRecursive(set, targetSum, newSum, i + 1);
		if (result == null)
		{
			continue;
		}

		result.Add(set[i]);
		return result;
	}

	return null;
}

public static void Main(string[] args)
{
	const int sum = 47;
	var set = new[] { 100, 40, 5, 1, 1, 1, 1 };
	
	var result = FindRecursive(set, sum, 0, 0);
	Console.WriteLine(
		result?.Select(x =&amp;gt; x.ToString()).Aggregate((x, y) =&amp;gt; x + &amp;quot;,&amp;quot; + y) ?? &amp;quot;null&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dynamic-programming&#34;&gt;Dynamic programming&lt;/h2&gt;
&lt;p&gt;This problem can be solved in pseudo-polynomial time using dynamic programming (a method for solving a complex problem by breaking it down into a collection of simpler subproblems). Define the boolean-valued function &lt;em&gt;Q(n, s)&lt;/em&gt; so that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q(n, 0) = true (return empty set)&lt;/li&gt;
&lt;li&gt;Q(0, s) = false, if s &amp;gt; 0 (you can&amp;rsquo;t pick a positive sum with an empty set)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then all other cases are: &lt;em&gt;Q(n, s) = Q(n-1, s) || Q(n-1, s-aₙ)&lt;/em&gt;. The only thing left is to fill the array of values of Q(i, s) for 1 ≤ i ≤ n using a simple recursion. The complexity of this method is &lt;em&gt;O(n*s)&lt;/em&gt; which is linear.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s see how it works in the example: Given a set A {1, 2, 5, 7}, is there subset whose sum is 9?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sum of 0 can be picked for any n with an empty set, the only sum that can be picked with an empty set is 0.&lt;/li&gt;
&lt;/ol&gt;
&lt;table width=&#34;681&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Adding 1 to the set we can now pick a sum of 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;table width=&#34;681&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Adding 2 to the set we can now pick a sum of 2 and 3 and we already can pick 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;table width=&#34;681&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt; true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt; false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Complete the table. Here is the answer shown in red.&lt;/li&gt;
&lt;/ol&gt;
&lt;table width=&#34;681&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;width: 58px; text-align: center; background-color: #ed8585;&#34;&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;How to restore the set. We got the correct answer after adding 7 to the set, so let&amp;rsquo;s remove it: 9-7=2. We got a sum of 2 after adding 2 to the set, so let&amp;rsquo;s remove it. Now we are at the sum of 0, so the restoration is over. The track is shown in yellow.&lt;/li&gt;
&lt;/ol&gt;
&lt;table width=&#34;681&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;width: 57px; text-align: center; background-color: #f0e5a8;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;width: 58px; text-align: center; background-color: #f0e5a8;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;width: 58px; text-align: center; background-color: #f0e5a8;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;width: 33px;&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 57px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;width: 58px; text-align: center; background-color: #f0e5a8;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align: center; width: 58px;&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;width: 58px; text-align: center; background-color: #f0e5a8;&#34;&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;And finally, here is the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static List&amp;lt;int&amp;gt; FindDP(int[] set, int sum)
{
	var solution = new bool[set.Length + 1, sum + 1];
	for (var i = 0; i &amp;lt;= set.Length; i++)
	{
		solution[i, 0] = true;
	}

	for (var i = 1; i &amp;lt;= set.Length; i++)
	{
		for (var j = 1; j &amp;lt;= sum; j++)
		{
			solution[i, j] = solution[i - 1, j];

			if (!solution[i, j] &amp;amp;&amp;amp; j &amp;gt;= set[i - 1])
			{
				solution[i, j] = solution[i, j] || solution[i - 1, j - set[i - 1]];
			}
		}

		if (!solution[i, sum])
		{
			continue;
		}

		var result = new List&amp;lt;int&amp;gt;();
		var q = sum;
		for (var p = i - 1; p &amp;gt;= 0; p--)
		{
			if (solution[p, q])
			{
				continue;
			}

			var s = set[p];
			result.Add(s);
			q -= s;
		}

		return result;
	}

	return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ps&#34;&gt;PS&lt;/h2&gt;
&lt;p&gt;Solving this task I&amp;rsquo;ve started thinking about making a github repo for such algorithms, so that one can easily find an implementation of a needed algorithm in c# or simply use it without needing to reinvent the wheel.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Manipulating Data With Iterators in Go</title>
      <link>/post/manipulating-data-with-iterators-in-go/</link>
      <pubDate>Sat, 16 Jul 2016 23:53:00 +0300</pubDate>
      <guid>/post/manipulating-data-with-iterators-in-go/</guid>
      <description>&lt;p&gt;Several months ago I started learning Go language and came across an interesting library 
&lt;a href=&#34;https://github.com/ahmetalpbalkan/go-linq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-linq&lt;/a&gt; which is an implementation of Microsoft’s 
&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/bb397926.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LINQ&lt;/a&gt; technology in Go. And while it is a good library I find its performance to be really weak because of its design. Trying to improve the situation resulted in a complete rewrite using iterators in a lightweight and simple manner.&lt;/p&gt;
&lt;h2 id=&#34;go-linq&#34;&gt;go-linq&lt;/h2&gt;
&lt;p&gt;The key type there is Query:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Query struct {
	values []T
	err    error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It stores all the data in its &lt;code&gt;values&lt;/code&gt; field and is a receiver for all the methods defined to manipulate data. Each time a method is executed it generates a new Query with a new &lt;code&gt;values&lt;/code&gt; slice. So, for example, a Where() method can be implemented as simply as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (q Query) Where(f func(T) (bool, error)) (r Query) {
	for _, i := range q.values {
		ok, err := f(i)
		if err != nil {
			r.err = err
			return r
		}
		if ok {
			r.values = append(r.values, i)
		}
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And although it generally is a good idea, it has poor performance for several reasons. First, each method allocates a new slice, so when you chain methods (as you normally do in linq), like &lt;code&gt;From(slice).Where(wat).Select(dat)&lt;/code&gt; , a lot of slices are created. This results in redundant memory traffic and additional garbage collection. Secondly, since it is a push model, each method manipulates the whole collection, even if there is only a single element needed in the end, e. g.  &lt;code&gt;From(slice).Where(wat).First()&lt;/code&gt; . In this case the &lt;code&gt;wat&lt;/code&gt;  predicate is executed for each element in the slice even if First() takes a single item.&lt;/p&gt;
&lt;h2 id=&#34;iterator-approach&#34;&gt;Iterator approach&lt;/h2&gt;
&lt;p&gt;In order to get rid of the problems shown above, I decided to rewrite the library from scratch using the iterator pattern. Iterator is a design pattern which is used to traverse a container and access the container&amp;rsquo;s elements. It decouples algorithms from containers, which is exactly what is needed to achieve a pull model, so that the predicate in the previous example can be executed only for the elements that are really needed. According to the Gang of Four iterator prescribes the following interface for iteration over a container with elements of type T:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Iterator {
    void First();    // Restart iteration
    void Next();     // Advance to next item
    bool IsDone();   // Are we done yet?
    T CurrentItem(); // Get current item
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In C# (where LINQ originated) iterator is called an Enumerator and implements the following interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public interface IEnumerator
{
    object Current { get; }
    bool MoveNext();
    void Reset();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But as Go is about simplicity, I wanted my iterators to be as lightweight as possible. So decided to omit the Reset() method (as it is not really needed in LINQ) and benefit from Go&amp;rsquo;s ability to return multiple values. So I ended with the following pattern:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Iterator func() (item interface{}, ok bool)

type Query struct {
    Iterate func() Iterator
}

next := query.Iterate()
for item, ok := next(); ok; item, ok = next() {
    fmt.Println(item)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now it became really simple to work with. Each time next() is called it returns the next element of the container and the boolean value indicating whether this element exists. Now the Where() method mentioned above can be rewritten in this way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (q Query) Where(predicate func(interface{}) bool) Query {
	return Query{
		Iterate: func() Iterator {
			next := q.Iterate()

			return func() (item interface{}, ok bool) {
				for item, ok = next(); ok; item, ok = next() {
					if predicate(item) {
						return
					}
				}

				return
			}
		},
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now Where() doesn&amp;rsquo;t really process anything, instead it generates a new iterator that will manipulate data only when it is iterated.&lt;/p&gt;
&lt;h2 id=&#34;benchmark&#34;&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;Rewriting each method to use iterators instead of slices increased  the performance dramatically. For example, talking about the previously mentioned case  &lt;code&gt;From(slice).Where(wat).First()&lt;/code&gt; the source slice now is scanned only until the first element that satisfies the &lt;code&gt;wat&lt;/code&gt; condition is found. Another good thing is that it allocates no additional memory. Lets make a simple benchmark comparing the iterators approach to go-linq&amp;rsquo;s:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
	size = 1000000
)

func BenchmarkSelectWhereFirst(b *testing.B) {
	for n := 0; n &amp;lt; b.N; n++ {
		Range(1, size).Select(func(i interface{}) interface{} {
			return -i.(int)
		}).Where(func(i interface{}) bool {
			return i.(int) &amp;gt; -1000
		}).First()
	}
}

func BenchmarkSelectWhereFirst_golinq(b *testing.B) {
	for n := 0; n &amp;lt; b.N; n++ {
		golinq.Range(1, size).Select(func(a golinq.T) (golinq.T, error) {
			return -a.(int), nil
		}).Where(func(a golinq.T) (bool, error) {
			return a.(int) &amp;gt; -1000, nil
		}).First()
	}
}

func BenchmarkSum(b *testing.B) {
	for n := 0; n &amp;lt; b.N; n++ {
		Range(1, size).Where(func(i interface{}) bool {
			return i.(int)%2 == 0
		}).SumInts()
	}
}

func BenchmarkSum_golinq(b *testing.B) {
	for n := 0; n &amp;lt; b.N; n++ {
		golinq.Range(1, size).Where(func(a golinq.T) (bool, error) {
			return a.(int)%2 == 0, nil
		}).Sum()
	}
}

func BenchmarkZipSkipTake(b *testing.B) {
	for n := 0; n &amp;lt; b.N; n++ {
		Range(1, size).Zip(Range(1, size).Select(func(i interface{}) interface{} {
			return i.(int) * 2
		}), func(i, j interface{}) interface{} {
			return i.(int) + j.(int)
		}).Skip(2).Take(5)
	}
}

func BenchmarkZipSkipTake_golinq(b *testing.B) {
	for n := 0; n &amp;lt; b.N; n++ {
		golinq.Range(1, size).Zip(golinq.Range(11, size).Select(func(i golinq.T) (golinq.T, error) {
			return i.(int) * 2, nil
		}), func(i, j golinq.T) (golinq.T, error) {
			return i.(int) + j.(int), nil
		}).Skip(2).Take(5)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result of this benchmark on my machine (MacBookPro8,1 Intel Core i5 2,4 GHz):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BenchmarkSelectWhereFirst-4          3000000           561 ns/op         224 B/op         10 allocs/op
BenchmarkSelectWhereFirst_golinq-4         2     555810859 ns/op    120546360 B/op   2000085 allocs/op
BenchmarkSum-4                            20      73847428 ns/op     8000289 B/op    1000019 allocs/op
BenchmarkSum_golinq-4                      5     253731714 ns/op    69161392 B/op    1000053 allocs/op
BenchmarkZipSkipTake-4               5000000           351 ns/op         192 B/op          6 allocs/op
BenchmarkZipSkipTake_golinq-4              2     672403213 ns/op    144520824 B/op   3000075 allocs/op
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;resume&#34;&gt;Resume&lt;/h2&gt;
&lt;p&gt;As you can see using this technique you can easily implement methods with lazy execution which seriously outperform a more straightforward and immediate execution. I have already implemented all the methods from traditional LINQ. This work can be found in my github repository 
&lt;a href=&#34;https://github.com/kalaninja/go2linq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go2linq&lt;/a&gt;. Feel free to use it, ask for improvements or implement new methods.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
